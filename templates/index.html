<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Cartes Navigation</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        html, body { height: 100%; margin: 0; }
        #map {
            width: 100%;
            height: 100vh;
            position: fixed;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        strong {
            color : #3a3fd0;
        }
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
        }
        .legend label {
            display: block;
            margin-bottom: 5px;
        }
        .legend input {
            width: 60px;
            margin-right: 5px;
            padding: 4px;
        }
        .legend button {
            padding: 4px 8px;
            background: #1e88e5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .legend button:hover {
            background: #1976d2;
        }
        #projectionInfo {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        .leaflet-control-layers {
            position: absolute !important;
            top: 90px !important;
            right: 0px !important;
            background: white;
            padding: 10px;
            border-radius: 4px;
            width: 130px !important;
            min-width: 130px !important;
        }
        .ship-marker {
            display: flex;
            align-items: center;
            justify-content: center;
        }

    .custom-ship-icon {
    background: none;
    border: none;
    }
    .ship-icon {
        width: 30px;
        height: 25px;
    }
    .ship-icon img {
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

        .center-button {
            position: absolute;
            right: 10px;
            top: 35%;
            transform: translateY(-50%);
            z-index: 1000;
            width: 30px;
            height: 30px;
            background: white;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .center-button:hover {
            background-color: #0000FF;
        }

@keyframes dashmove {
0% {
    stroke-dashoffset: 0;
}
100% {
    stroke-dashoffset: -20;
}
}

.animated-dash {
    animation: dashmove 1s linear infinite;
}

    </style>
</head>
<body>

<div id="map"></div>
<div id="info"></div>
<button class="center-button" onclick="centerOnBoat()" title="Centrer sur le bateau">üëÄ</button>

<div class="legend">
    <label for="projectionTime">Temps de projection (minutes):</label>
    <input type="number" id="projectionTime" min="0" max="1440" step="15" value="15">
    <button onclick="updateProjectionTime()">Appliquer</button>
    <div id="projectionInfo"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const initialPosition = [43.2438, 5.3656];
    console.log('Position initiale:', initialPosition);

    // Variable globale pour le temps de projection
    let projectionHours = 0.25;

const map = L.map('map', {
center: initialPosition,
zoomSnap: 1,
zoomDelta: 1,
minZoom: 2,
maxZoom: 18,
keepInView: false,  // Emp√™che le recentrage automatique
maxBounds: null,    // Supprime les limites de la carte
maxBoundsViscosity: 0  // D√©sactive la "viscosit√©" des limites
}).setView(initialPosition, 13);


    const info = document.getElementById('info');
    function updateInfo(text) {
        info.innerHTML = text;
    }

// Fonction pour mettre √† jour le temps de projection
function updateProjectionTime() {
updatePosition();
const input = document.getElementById('projectionTime');
const minutes = parseFloat(input.value);

if (minutes >= 0 && minutes <= 1440) {
    projectionHours = minutes / 60;  // Conversion des minutes en heures
    document.getElementById('projectionInfo').innerHTML =
        `Projection sur ${minutes.toFixed(0)} minutes`;
    // Mettre √† jour tous les navires avec la nouvelle projection
    updateAISData();
} else {
    alert('Veuillez entrer une valeur inf√©rieur √† 1440 minutes soit 24 heures');
    input.value = projectionHours * 60;  // Reconversion en minutes pour l'affichage
}
}

// Initialisation de l'affichage du temps de projection
document.addEventListener('DOMContentLoaded', function() {
document.getElementById('projectionTime').value = (projectionHours * 60).toFixed(0);
document.getElementById('projectionInfo').innerHTML =
    `Projection sur ${(projectionHours * 60).toFixed(0)} minutes`;
});

// Ic√¥ne personnalis√©e pour votre bateau principal
const customIcon = L.divIcon({
    html: `<div class="ship-icon">

    </div>`,
    className: ''
});


// Variable globale pour le marker
let shipMarker = null;

// Fonction pour nettoyer tous les markers de la carte
const clearAllMarkers = () => {
    map.eachLayer((layer) => {
        if (layer instanceof L.Marker) {
            map.removeLayer(layer);
        }
    });
    shipMarker = null;
};

// Fonction pour mettre √† jour le marker
const updateShipMarker = (position, angle) => {

    // Normalisation de l'angle
    let normalizedAngle = ((angle % 360) + 360) % 360;

    // D√©termine si l'image doit √™tre invers√©e (quand l'angle est entre 0 et 180)
    const shouldFlip = normalizedAngle > 0 && normalizedAngle < 180;

    // Ajustement de l'angle pour l'orientation correcte de l'image
    const adjustedAngle = normalizedAngle - 270;

    const customIcon = L.divIcon({
        html: `<div class="ship-icon" id="unique-ship-icon">
            <img src="/static/VoilierImage.png"
                 style="transform:
                        rotate(${adjustedAngle}deg)
                        scaleY(${shouldFlip ? -1 : 1});
                        width: 30px; height: 30px;
                        transition: all 0.3s ease;">
        </div>`,
        className: 'custom-ship-icon',
        iconSize: [30, 30],
        iconAnchor: [15, 15]
    });


    // Cr√©er un nouveau marker
    shipMarker = L.marker(position, {
        icon: customIcon
    }).addTo(map);
};

// Initialisation
const initializeShip = () => {
    const initialPosition = [43.2438, 5.3656];
    updateShipMarker(initialPosition, 0);
};

// Attendre que la carte soit pr√™te
map.whenReady(() => {
    //clearAllMarkers(); // Nettoyer avant l'initialisation
    initializeShip();
});


// Couche MBTiles
// D√©finition des diff√©rentes couches MBTiles
const mondeTileLayer = L.tileLayer('/tile/cartes1.mbtiles/{z}/{x}/{y}', {
tms: true,
opacity: 0.7,
attribution: 'MBTiles Map - Monde',
maxZoom: 18,
minZoom: 2
});

const merTileLayer = L.tileLayer('/tile/cartes2.mbtiles/{z}/{x}/{y}', {
tms: true,
opacity: 0.7,
attribution: 'MBTiles Map - Marseille',
maxZoom: 18,
minZoom: 2
});

const navionicsTileLayer = L.tileLayer('/tile/cartes3.mbtiles/{z}/{x}/{y}', {
tms: true,
opacity: 0.7,
attribution: 'MBTiles Map - Navionics',
maxZoom: 18,
minZoom: 2
});

const corseTileLayer = L.tileLayer('/tile/cartes4.mbtiles/{z}/{x}/{y}', {
tms: true,
opacity: 0.7,
attribution: 'MBTiles Map - Navionics',
maxZoom: 18,
minZoom: 2
});

// Ajout de la couche par d√©faut
mondeTileLayer.addTo(map);

// Contr√¥le des couches avec les diff√©rentes cartes
const baseMaps = {
"Carte Planette": mondeTileLayer,
"Carte SonarChart": merTileLayer,
"Carte Navionics": navionicsTileLayer
};

    L.control.layers(baseMaps, null, {collapsed: false}).addTo(map);

    // Marqueur principal
    const currentMarker = L.marker(initialPosition, {
    icon: customIcon,
    }).addTo(map)
    .bindPopup("Salut tout le monde ! Je suis HUAHINE");
    //.openPopup();

    // Suivi de la position
    const polyline = L.polyline([initialPosition], {
        color: 'red',
        weight: 3,
        opacity: 0.7
    }).addTo(map);


// Ensuite, modifions la d√©finition de la ligne
const projectionLine = L.polyline([], {
    color: '#1e88e5',
    weight: 2,
    opacity: 0.8,
    dashArray: '7, 7',
    className: 'animated-dash'  // Ajout de la classe pour l'animation
}).addTo(map);

    updateInfo(`Zoom: ${map.getZoom()+1}<br>Position: ${initialPosition[0].toFixed(5)}, ${initialPosition[1].toFixed(5)}`);

    // Stockage des marqueurs AIS et des lignes de vitesse
    const aisMarkers = {};
    const speedLines = {};

    // Fonction pour convertir les milles nautiques en degr√©s
    function nauticalMilesToDegrees(nauticalMiles) {
        return nauticalMiles / 60;
    }

    // Fonction pour mettre √† jour ou cr√©er un marqueur AIS
    function updateAISMarker(ship) {
        console.log("Mise √† jour/cr√©ation du marqueur pour MMSI:", ship.mmsi);
        const shipColor = ship.class === 'A' ? '#FF0000' : '#00FF00';  // Rouge pour classe A, Vert pour classe B

        // Cr√©er un ic√¥ne rotatif bas√© sur le cap du navire
        const rotatedShipIcon = L.divIcon({
            html: `<div class="ship-icon" style="transform: rotate(${ship.cog}deg);">
                <svg viewBox="0 0 100 100" style="width: 24px; height: 24px;">
                    <path fill="${shipColor}" stroke="white" stroke-width="2"
                        d="M50,10 L80,80 L50,65 L20,80 Z"/>
                </svg>
            </div>`,
            className: 'ship-marker',
            iconSize: [12, 12],
            iconAnchor: [6, 6]
        });

        // Calculer la distance parcourue
        const speed = ship.sog || 0; // vitesse en n≈ìuds
        const distanceInNauticalMiles = speed * projectionHours;
        const distanceInDegrees = nauticalMilesToDegrees(distanceInNauticalMiles);

        // Calculer le point final de la ligne de vitesse
        const headingRad = (ship.cog * Math.PI) / 180;

        // Calculer les coordonn√©es du point final
        const endLat = ship.latitude + distanceInDegrees * Math.cos(headingRad);
        const endLon = ship.longitude + distanceInDegrees * Math.sin(headingRad);

        // Mettre √† jour ou cr√©er la ligne de vitesse
        if (speedLines[ship.mmsi]) {
            speedLines[ship.mmsi].setLatLngs([
                [ship.latitude, ship.longitude],
                [endLat, endLon]
            ]);
        } else {
            speedLines[ship.mmsi] = L.polyline(
                [[ship.latitude, ship.longitude], [endLat, endLon]],
                {
                    color: '#1e88e5',
                    weight: 2,
                    opacity: 0.8,
                    dashArray: '5, 5'
                }
            ).addTo(map);
        }

        // Contenu de la popup avec les informations de projection
        const popupContent = `
            <strong>${ship.name || 'Navire inconnu'}</strong><br>
            <strong>Navire AIS Classe ${ship.class}</strong><br>
            MMSI: ${ship.mmsi}<br>
            Position: ${ship.latitude.toFixed(5)}, ${ship.longitude.toFixed(5)}<br>
            Cap: ${ship.cog}¬∞<br>
            Vitesse: ${ship.sog ? ship.sog.toFixed(1) : 'N/A'} n≈ìuds<br>
            Distance projet√©e: ${distanceInNauticalMiles.toFixed(1)} NM sur ${(projectionHours * 60).toFixed(0)} min
        `;

        if (aisMarkers[ship.mmsi]) {
            // Mise √† jour d'un marqueur existant
            aisMarkers[ship.mmsi].setLatLng([ship.latitude, ship.longitude]);
            aisMarkers[ship.mmsi].setIcon(rotatedShipIcon);
            aisMarkers[ship.mmsi].getPopup().setContent(popupContent);
        } else {
            // Cr√©ation d'un nouveau marqueur
            aisMarkers[ship.mmsi] = L.marker([ship.latitude, ship.longitude], {
                icon: rotatedShipIcon
            }).addTo(map);
            aisMarkers[ship.mmsi].bindPopup(popupContent);
        }
    }

    // Fonction de mise √† jour des donn√©es AIS
    async function updateAISData() {
        try {
            console.log("R√©cup√©ration des donn√©es AIS...");
            const response = await fetch('/get_ships');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const ships = await response.json();
            console.log("Donn√©es AIS re√ßues:", ships);

            // Mettre √† jour chaque navire
            ships.forEach(ship => updateAISMarker(ship));

            // Supprimer les marqueurs des navires qui ne sont plus pr√©sents
            Object.keys(aisMarkers).forEach(mmsi => {
                if (!ships.find(ship => ship.mmsi === mmsi)) {
                    console.log("Suppression du navire:", mmsi);
                    map.removeLayer(aisMarkers[mmsi]);
                    if (speedLines[mmsi]) {
                        map.removeLayer(speedLines[mmsi]);
                        delete speedLines[mmsi];
                    }
                    delete aisMarkers[mmsi];
                }
            });
        } catch (err) {
            console.error("Erreur lors de la mise √† jour des donn√©es AIS:", err);
        }
    }


// Fonction de mise √† jour de la position principale
async function updatePosition() {
    try {
        const response = await fetch('/api/get_coordinates');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        if (data.latitude && data.longitude) {
            const newLatLng = new L.LatLng(data.latitude, data.longitude);

            // Mise √† jour du marker avec la nouvelle position et rotation
            updateShipMarker([data.latitude, data.longitude], data.cog || 0);

            polyline.addLatLng(newLatLng);

            // Calcul de la projection
            const speed = data.speed || 0;
            const cog = data.cog || 0;

            const distanceInNauticalMiles = speed * projectionHours;
            const distanceInDegrees = nauticalMilesToDegrees(distanceInNauticalMiles);
            const headingRad = (cog * Math.PI) / 180;
            const endLat = data.latitude + distanceInDegrees * Math.cos(headingRad);
            const endLon = data.longitude + distanceInDegrees * Math.sin(headingRad);

            // Mise √† jour de la ligne de projection
            projectionLine.setLatLngs([
                [data.latitude, data.longitude],
                [endLat, endLon]
            ]);

            // Mise √† jour du popup
            if (shipMarker) {
                shipMarker.bindPopup(`
                    <strong>HUAHINE</strong><br>
                    Position: ${data.latitude.toFixed(5)}, ${data.longitude.toFixed(5)}<br>
                    Cap: ${cog}¬∞<br>
                    Vitesse: ${speed.toFixed(1)} n≈ìuds<br>
                    Distance projet√©e: ${distanceInNauticalMiles.toFixed(1)} NM sur ${(projectionHours * 60).toFixed(0)} min
                `);
            }

            updateInfo(`
                Zoom: ${map.getZoom()+1}<br>
                Position: ${data.latitude.toFixed(5)}, ${data.longitude.toFixed(5)}<br>
                Cap: ${cog}¬∞<br>
                Vitesse: ${speed.toFixed(1)} n≈ìuds
            `);
        }
    } catch (err) {
        console.error("Erreur de mise √† jour des coordonn√©es:", err);
    }
}

    // Intervalles de mise √† jour
    clearAllMarkers();
    updatePosition();
    const updateInterval = setInterval(updatePosition, 3000);
    const aisUpdateInterval = setInterval(updateAISData, 10000);

    // Premier appel imm√©diat pour les donn√©es AIS
    updateAISData();

    // √âv√©nements de la carte
    map.on('moveend zoomend', () => {
        const center = map.getCenter();
        updateInfo(`Zoom: ${map.getZoom()+1}<br>Position: ${center.lat.toFixed(5)}, ${center.lng.toFixed(5)}`);
    });

    // Nettoyage √† la fermeture
    window.onbeforeunload = function() {
        clearInterval(updateInterval);
        clearInterval(aisUpdateInterval);
    };

    function centerOnBoat() {
    if (shipMarker) {
        const currentPosition = shipMarker.getLatLng();
        const currentZoom = map.getZoom();
        map.setView(currentPosition, currentZoom);
    }
}

</script>
</body>
</html>